# @catch

The `@catch` decorator ensures that a step will succeed, despite any errors in the user code or transient platform issues.

It is best used in conjunction with the `@retry` decorator: After all retries have been exhausted, `@catch` executes a no-op task that allows the run to continue. For more information, see [Dealing with Failures](/scaling/failures).

<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! Instead, edit the notebook w/the location & name as this file. -->


<DocSection type="decorator" name="catch" module="metaflow" show_import="True" heading_level="3" link="https://github.com/Netflix/metaflow/tree/master/metaflow/plugins/catch_decorator.py#L22">
<SigArgSection>
<SigArg name="..." />
</SigArgSection>
<Description summary="Specifies that the step will success under all circumstances." extended_summary="The decorator will create an optional artifact, specified by `var`, which\ncontains the exception raised. You can use it to detect the presence\nof errors, indicating that all happy-path artifacts produced by the step\nare missing." />
<ParamSection name="Parameters">
	<Parameter name="var" type="str, optional, default None" desc="Name of the artifact in which to store the caught exception.\nIf not specified, the exception is not stored." />
	<Parameter name="print_exception" type="bool, default True" desc="Determines whether or not the exception is printed to\nstdout when caught." />
</ParamSection>
</DocSection>

